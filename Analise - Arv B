/*
Análise de complexidade algorítmica - Árvore B
Operações: Inserção e Remoção
Ordens: 1, 5 e 10
Tamanhos: 100 a 10000 elementos
*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct no {
    int total;
    int* chaves;
    struct no** filhos;
    struct no* pai;
} No;

typedef struct arvoreB {
    No* raiz;
    int ordem;
} ArvoreB;

// Contador de operações
long long contadorOperacoes = 0;

// Declarações antecipadas
No* criaNo(ArvoreB* arvore);
void adicionaChaveRecursivo(ArvoreB* arvore, No* no, No* novo, int chave);

// Criação da árvore e nós
ArvoreB* criaArvore(int ordem) {
    ArvoreB* a = malloc(sizeof(ArvoreB));
    a->ordem = ordem;
    a->raiz = criaNo(a);
    return a;
}

No* criaNo(ArvoreB* arvore) {
    int max = arvore->ordem * 2;
    No* no = malloc(sizeof(No));
    no->pai = NULL;
    no->chaves = malloc(sizeof(int) * (max + 1));
    no->filhos = malloc(sizeof(No*) * (max + 2));
    no->total = 0;
    for (int i = 0; i < max + 2; i++)
        no->filhos[i] = NULL;
    return no;
}

// Pesquisa binária
int pesquisaBinaria(No* no, int chave) {
    int inicio = 0, fim = no->total - 1, meio;
    while (inicio <= fim) {
        contadorOperacoes++;
        meio = (inicio + fim) / 2;
        if (no->chaves[meio] == chave)
            return meio;
        else if (no->chaves[meio] > chave)
            fim = meio - 1;
        else
            inicio = meio + 1;
    }
    return inicio;
}

// Localiza o nó folha apropriado
No* localizaNo(ArvoreB* arvore, int chave) {
    No *no = arvore->raiz;
    while (no != NULL) {
        contadorOperacoes++;
        int i = pesquisaBinaria(no, chave);
        if (no->filhos[i] == NULL)
            return no;
        else
            no = no->filhos[i];
    }
    return NULL;
}

// Adiciona chave no nó
void adicionaChaveNo(No* no, No* direita, int chave) {
    int i = pesquisaBinaria(no, chave);
    for (int j = no->total - 1; j >= i; j--) {
        contadorOperacoes++;
        no->chaves[j + 1] = no->chaves[j];
        no->filhos[j + 2] = no->filhos[j + 1];
    }
    no->chaves[i] = chave;
    no->filhos[i + 1] = direita;
    no->total++;
}

// Verifica transbordo
int transbordo(ArvoreB *arvore, No *no) {
    return no->total > arvore->ordem * 2;
}

// Divide o nó
No* divideNo(ArvoreB* arvore, No* no) {
    int meio = no->total / 2;
    No* novo = criaNo(arvore);
    novo->pai = no->pai;
    for (int i = meio + 1; i < no->total; i++) {
        contadorOperacoes++;
        novo->filhos[novo->total] = no->filhos[i];
        novo->chaves[novo->total] = no->chaves[i];
        if (novo->filhos[novo->total] != NULL)
            novo->filhos[novo->total]->pai = novo;
        novo->total++;
    }
    novo->filhos[novo->total] = no->filhos[no->total];
    if (novo->filhos[novo->total] != NULL)
        novo->filhos[novo->total]->pai = novo;
    no->total = meio;
    return novo;
}

// Inserção recursiva
void adicionaChaveRecursivo(ArvoreB* arvore, No* no, No* novo, int chave) {
    contadorOperacoes++;
    adicionaChaveNo(no, novo, chave);
    if (transbordo(arvore, no)) {
        int promovido = no->chaves[arvore->ordem];
        No* novo = divideNo(arvore, no);
        if (no->pai == NULL) {
            No* raiz = criaNo(arvore);
            raiz->filhos[0] = no;
            adicionaChaveNo(raiz, novo, promovido);
            no->pai = raiz;
            novo->pai = raiz;
            arvore->raiz = raiz;
        } else {
            adicionaChaveRecursivo(arvore, no->pai, novo, promovido);
        }
    }
}

// Inserção principal
void adicionaChave(ArvoreB* arvore, int chave) {
    No* no = localizaNo(arvore, chave);
    adicionaChaveRecursivo(arvore, no, NULL, chave);
}

// Remoção simplificada - remove apenas de folhas
void removeChave(ArvoreB* arvore, int chave) {
    No *no = arvore->raiz;
    
    // Busca a chave
    while (no != NULL) {
        contadorOperacoes++;
        int i = pesquisaBinaria(no, chave);
        
        // Se encontrou a chave em uma folha, remove
        if (i < no->total && no->chaves[i] == chave && no->filhos[0] == NULL) {
            for (int j = i; j < no->total - 1; j++) {
                contadorOperacoes++;
                no->chaves[j] = no->chaves[j + 1];
            }
            no->total--;
            return;
        }
        
        // Continua a busca
        if (no->filhos[i] != NULL)
            no = no->filhos[i];
        else
            return; // Não encontrou
    }
}

// Libera memória
void liberaNo(No* no) {
    if (no != NULL) {
        for (int i = 0; i <= no->total; i++) {
            if (no->filhos[i] != NULL)
                liberaNo(no->filhos[i]);
        }
        free(no->chaves);
        free(no->filhos);
        free(no);
    }
}

void liberaArvore(ArvoreB* arvore) {
    liberaNo(arvore->raiz);
    free(arvore);
}

// Gera chaves aleatórias
void geraChavesAleatorias(int* chaves, int n) {
    for (int i = 0; i < n; i++) {
        chaves[i] = rand() % (n * 10);
    }
}

// Testa inserção
void testaInsercao(int ordem, int tamanho, double* tempoMedio, double* operacoesMedio) {
    const int NUM_AMOSTRAS = 10;
    double tempoTotal = 0;
    long long operacoesTotal = 0;
    
    for (int amostra = 0; amostra < NUM_AMOSTRAS; amostra++) {
        int* chaves = malloc(sizeof(int) * tamanho);
        geraChavesAleatorias(chaves, tamanho);
        
        ArvoreB* arvore = criaArvore(ordem);
        contadorOperacoes = 0;
        
        clock_t inicio = clock();
        for (int i = 0; i < tamanho; i++) {
            adicionaChave(arvore, chaves[i]);
        }
        clock_t fim = clock();
        
        tempoTotal += (double)(fim - inicio) / CLOCKS_PER_SEC;
        operacoesTotal += contadorOperacoes;
        
        liberaArvore(arvore);
        free(chaves);
    }
    
    *tempoMedio = tempoTotal / NUM_AMOSTRAS;
    *operacoesMedio = (double)operacoesTotal / NUM_AMOSTRAS;
}

// Testa remoção
void testaRemocao(int ordem, int tamanho, double* tempoMedio, double* operacoesMedio) {
    const int NUM_AMOSTRAS = 10;
    double tempoTotal = 0;
    long long operacoesTotal = 0;
    
    for (int amostra = 0; amostra < NUM_AMOSTRAS; amostra++) {
        int* chaves = malloc(sizeof(int) * tamanho);
        geraChavesAleatorias(chaves, tamanho);
        
        // Insere todos os elementos
        ArvoreB* arvore = criaArvore(ordem);
        for (int i = 0; i < tamanho; i++) {
            adicionaChave(arvore, chaves[i]);
        }
        
        // Remove metade
        contadorOperacoes = 0;
        clock_t inicio = clock();
        for (int i = 0; i < tamanho / 2; i++) {
            removeChave(arvore, chaves[i]);
        }
        clock_t fim = clock();
        
        tempoTotal += (double)(fim - inicio) / CLOCKS_PER_SEC;
        operacoesTotal += contadorOperacoes;
        
        liberaArvore(arvore);
        free(chaves);
    }
    
    *tempoMedio = tempoTotal / NUM_AMOSTRAS;
    *operacoesMedio = (double)operacoesTotal / NUM_AMOSTRAS;
}

// Programa principal
int main() {
    srand(time(NULL));
    
    int ordens[] = {1, 5, 10};
    int tamanhos[] = {100, 500, 1000, 2500, 5000, 7500, 10000};
    
    printf("=== ANÁLISE DE COMPLEXIDADE - ÁRVORE B ===\n\n");
    
    // Análise de inserção
    printf("INSERÇÃO:\n");
    printf("%-10s %-10s %-15s %-20s\n", "Ordem", "Tamanho", "Tempo (s)", "Operações");
    printf("----------------------------------------------------------------\n");
    
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 7; j++) {
            double tempo, operacoes;
            testaInsercao(ordens[i], tamanhos[j], &tempo, &operacoes);
            printf("%-10d %-10d %-15.6f %-20.0f\n", 
                   ordens[i], tamanhos[j], tempo, operacoes);
        }
        printf("\n");
    }
    
    // Análise de remoção
    printf("\nREMOÇÃO:\n");
    printf("%-10s %-10s %-15s %-20s\n", "Ordem", "Tamanho", "Tempo (s)", "Operações");
    printf("----------------------------------------------------------------\n");
    
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 7; j++) {
            double tempo, operacoes;
            testaRemocao(ordens[i], tamanhos[j], &tempo, &operacoes);
            printf("%-10d %-10d %-15.6f %-20.0f\n", 
                   ordens[i], tamanhos[j], tempo, operacoes);
        }
        printf("\n");
    }
    
    printf("\nObs: Remoção implementada apenas para nós folha (versão simplificada)\n");
    
    return 0;
}
